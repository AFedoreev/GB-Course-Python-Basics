# Постарайтесь использовать то, что мы прошли на уроке при решении этого ДЗ,
# вспомните про zip(), map(), lambda, посмотрите где лучше с ними, а где они излишни!

# Задание - 1
# Создайте функцию, принимающую на вход Имя, возраст и город проживания человека
# Функция должна возвращать строку вида "Василий, 21 год(а), проживает в городе Москва"

print("Задача 1-1.\n")
# из всех 3 задач - единственная подходящая для zip(), поэтому основной ввод через список

def zipit(name, age, town):
    # 3 строки в угоду чуть большей универсальности. Перевод в кортеж для работы zip(). Запись условия в одну строку
    # возможно не совсем соответствует PEP-8, но при всего одной операции думаю не особо усложняет читабельность
    if type(name) != tuple and type(name) != list: name = name,
    if type(age) != tuple and type(age) != list: age = age,
    if type(town) != tuple and type(town) != list: town = town,
    strings = [] # по условию задачи нужно вернуть строку(и)
    for elem in zip(name, age, town):
        strings.append(f'{elem[0]}, {elem[1]} год(а), проживает в городе {elem[2]}')
    return strings

def clean_list_print(list):
    for elem in list:
        print(elem)


names = ['Василий', 'Евгений', 'Елена']
ages = 21, 32, 25
towns = 'Москва', 'Мурманск', 'Саратов'

anketas = zipit(names, ages, towns)
# еще одна функция для более чистой распечатки списков, в столб, без скобок и кавычек
clean_list_print(anketas)
# проверка на работоспособность при прямом вводе и не списком/кортежем
clean_list_print(zipit('Вася', 27, 'Уфа'))

# Задание - 2
# Создайте функцию, принимающую на вход 3 числа, и возвращающую наибольшее из них

print("\nЗадача 1-2.\n")

import random
from functools import reduce # для реализации через lambda нужен reduce, судя по гуглу в питоне 2 является стандартным

# Вариант с рандомными числами для непрерывного исполнения кода при проверке
numbers = [random.randint(-100, 100) for _ in range(3)]
print(numbers)

# Вариант с ручным вводом
# numbers = input('Введите 3 числа через запятую : ').replace(' ', '').split(',')

max_numb = reduce(lambda x, y: x if (x > y) else y, numbers)
print(f'Максимальное число: {max_numb}')

# Задание - 3
# Создайте функцию, принимающую неограниченное количество строковых аргументов,
# верните самую длинную строку из полученных аргументов

print("\nЗадача 1-3.\n")


def longest_str(*args):
    longest_arg = ''
    for arg in args:
        print(arg)
        if len(arg) > len(longest_arg):
            longest_arg = arg
    return longest_arg


# кортеж наверное более практичен (даже лучше в комбинации с lambda/reduce как предыдущей задаче, но это будет повтор)),
# но акцент на неограниченность количества аргументов, намекает на *args, и если передавать аргументы в функцию в виде
# кортежа, то почемуто arg не выделяется из args, а явялется его копией
longest = longest_str('велосипед', 'колбаса', 'лес', 'навуходоносор')

print(f"\nСамое длинное слово из списка выше: {longest}")

# P.S. Никуда не пристроил map(), так как он пропускает через функцию объекты по очереди, без связи с результатом
# (может возможно через return в глобальную переменную, думаю приведет к лишнему усложенению кода), в отличие от reduce,
# идеально подходящего под поиск максимумов и пр.